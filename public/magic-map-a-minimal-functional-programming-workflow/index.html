<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="MyBlog">
    
    <link rel="shortcut icon" href="https://example.com/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.min.css">

    <title>Magic map() - a minimal functional programming workflow</title>
</head>
<body><header id="banner">
    <h2><a href="https://example.com">Martin&#39;s blog</a></h2>
    <nav>
        <ul>
            <li>
                <a href="/" title="posts">posts</a>
            </li><li>
                <a href="/about/" title="about">about</a>
            </li>
        </ul>
    </nav>
</header>
<main id="content">
<article>
    <header id="post-header">
        <h1>Magic map() - a minimal functional programming workflow</h1>
        <div>
                <time>Mar 19, 2021</time>
            </div>
    </header>
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>

<div id="TOC">

</div>

<p>“Form follows function” - <em>Louis Sullivan</em></p>
<p>Functional programming is simply about writing code with functions. Instead of repeating the same line of code over and over or using double-nested for loops, we can abstract the essence of what we are doing into functions. A function can then be elegantly applied to many inputs. Here, we will do this with <code>purrr::map()</code>, which I’m using day in and day out and which is a great starting point to dive into the world of functional programming.</p>
<p>Let’s go through some of the <code>map()</code>-magic with a minimal workflow to produce clean, robust and fast code. We will do a small genome-wide association study, an analysis looking at the association between genes and a trait by fitting a model over and over again for every SNP in the genome.</p>
<p>Here are some my favorite packages.</p>
<pre class="r"><code>library(purrr) # provides the key function here: map
library(furrr) # does map in parallel
library(dplyr) # does all sorts of magic
library(glue)  # concatenates strings beautifully
library(broom) # takes a model and returns a tidy data.frame</code></pre>
<p>Let’s see whether drinking coffee has a genetic basis. We make up a trait
(coffees per day) and 100 SNPs for 100 individuals.</p>
<div id="simulate-data" class="section level2">
<h2>Simulate data</h2>
<pre class="r"><code>coffees   &lt;- sample(1:6, 100, TRUE)
snps      &lt;- replicate(100, sample(c(0,1,2), 100, TRUE))
snp_names &lt;- paste0(&quot;snp&quot;, 1:100)

dat &lt;- data.frame(cbind(coffees, snps)) %&gt;% 
            setNames(c(&quot;coffees&quot;, snp_names))
            
head(dat[1:5, 1:7])</code></pre>
<pre><code>#&gt;   coffees snp1 snp2 snp3 snp4 snp5 snp6
#&gt; 1       1    1    2    1    0    1    1
#&gt; 2       5    1    1    2    0    0    2
#&gt; 3       6    1    2    0    1    1    0
#&gt; 4       5    0    2    2    1    1    2
#&gt; 5       3    0    2    1    2    0    1</code></pre>
</div>
<div id="write-a-function" class="section level2">
<h2>1) Write a function</h2>
<p>We could now do 100 linear models manually by writing 100 lines of code, or we could do a <code>for</code> loop.</p>
<p>Instead, let’s write a function to fit <em>one</em> model, and then apply this function to each SNP. We generally want the thing that changes (i.e. snp_name) to be the first argument. The function below fits a linear model of coffee consumption with a snp as predictor, and extracts the model estimate and p-value for the SNP. It returns a one-row <code>data.frame</code>. I generally like my functions to return data.frames, because that makes it easy to put together many function outputs into a big data.frame at the end.</p>
<pre class="r"><code>fit_model &lt;- function(snp_name, dat) {
      # write formula using SNP name
      model_formula &lt;- glue(&quot;coffees ~ {snp_name}&quot;)
      # fit linear model
      fit &lt;- lm(model_formula, data = dat) %&gt;% 
                  broom::tidy() %&gt;%        # tidy results
                  filter(term == snp_name) # extract snp
      return(fit)
      
}</code></pre>
</div>
<div id="use-map-to-apply-function-to-every-snp" class="section level2">
<h2>2) Use <code>map()</code> to apply function to every SNP</h2>
<p>Using a vector with <code>snp_names</code>, we can apply the function to every SNP. The structure of <code>map()</code> is always the same: map(list/vector, function, additional_arguments). <code>map()</code> always returns a list. We can convert the list to a data.frame with <code>dplyr::bind_rows()</code>.</p>
<pre class="r"><code># run gwas
gwas &lt;- map(snp_names, fit_model, dat) %&gt;% 
              bind_rows()
# print first three SNPs
gwas[1:3, ]</code></pre>
<pre><code>#&gt; # A tibble: 3 x 5
#&gt;   term  estimate std.error statistic p.value
#&gt;   &lt;chr&gt;    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;
#&gt; 1 snp1    0.0266     0.212     0.126   0.900
#&gt; 2 snp2    0.201      0.207     0.970   0.334
#&gt; 3 snp3   -0.323      0.202    -1.60    0.113</code></pre>
</div>
<div id="what-if-something-goes-wrong---map-safely" class="section level2">
<h2>3) What if something goes wrong? - <code>map()</code> safely</h2>
<p>Loops often fail becomes something goes wrong in one or a few iterations.Let’s introduce a non-existing SNP and try again to see how it fails</p>
<pre class="r"><code>snp_names2 &lt;- c(&quot;not_a_snp&quot;, snp_names)

gwas &lt;- map(snp_names2, fit_model, dat) %&gt;% 
      bind_rows()</code></pre>
<pre><code>#&gt; Error in eval(predvars, data, env): object &#39;not_a_snp&#39; not found</code></pre>
<p>We can make our gwas error-safe using <code>purrr::safely()</code>. This does some magic under the hood which isn’t so important now. For every iteration, it will return a list with two elements, one for the result and one for the error (equals NULL if there is no error). This way, we always get the results or errors of all our iterations back.</p>
<pre class="r"><code>fit_model_safely &lt;- purrr::safely(fit_model)

gwas &lt;- map(snp_names2, fit_model_safely, dat)
gwas[1:2]</code></pre>
<pre><code>#&gt; [[1]]
#&gt; [[1]]$result
#&gt; NULL
#&gt; 
#&gt; [[1]]$error
#&gt; &lt;simpleError in eval(predvars, data, env): object &#39;not_a_snp&#39; not found&gt;
#&gt; 
#&gt; 
#&gt; [[2]]
#&gt; [[2]]$result
#&gt; # A tibble: 1 x 5
#&gt;   term  estimate std.error statistic p.value
#&gt;   &lt;chr&gt;    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;
#&gt; 1 snp1    0.0266     0.212     0.126   0.900
#&gt; 
#&gt; [[2]]$error
#&gt; NULL</code></pre>
<p><code>map()</code> lets you extract a list element simply by its name. Here, we iterate over the list of results and extract all SNPs that worked.</p>
<pre class="r"><code>gwas &lt;- map(gwas, &quot;result&quot;) %&gt;% 
            bind_rows()
gwas[1:3, ]</code></pre>
<pre><code>#&gt; # A tibble: 3 x 5
#&gt;   term  estimate std.error statistic p.value
#&gt;   &lt;chr&gt;    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;
#&gt; 1 snp1    0.0266     0.212     0.126   0.900
#&gt; 2 snp2    0.201      0.207     0.970   0.334
#&gt; 3 snp3   -0.323      0.202    -1.60    0.113</code></pre>
</div>
<div id="what-if-it-takes-too-long---map-in-parallel" class="section level2">
<h2>4) What if it takes too long? - <code>map()</code> in parallel</h2>
<p>Once the idea of <code>map()</code> is clear, we can easily parallelise it to run on multiple cores. There is some overhead in collecting computations from several cores so this doesn’t make much sense when the running time is short. But for longer computations, using 4 cores instead of 1 should make it nearly 4 times as fast.</p>
<p>We can use the <code>furrr</code> package here, which mimics <code>purrr</code> functions but can run in parallel. It is based on <a href="https://cran.r-project.org/web/packages/future/vignettes/future-1-overview.html">future</a>, which is why all functions start with <code>future_</code>, for example <code>future_map()</code>. Unlike other ways of parallelising, this approach works on Windows, Mac and Linux. All we have to do now is to first set up a <code>plan()</code> …</p>
<pre class="r"><code># check available cores
availableCores()
# parallelises across 4 cores
plan(multiprocess, workers = 4)</code></pre>
<p>… and then replace <code>map()</code> with <code>future_map()</code>.</p>
<pre class="r"><code>gwas &lt;- future_map(snp_names, fit_model, dat) %&gt;% 
            bind_rows()
gwas[1:3, ]</code></pre>
<pre><code>#&gt; # A tibble: 3 x 5
#&gt;   term  estimate std.error statistic p.value
#&gt;   &lt;chr&gt;    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;
#&gt; 1 snp1    0.0266     0.212     0.126   0.900
#&gt; 2 snp2    0.201      0.207     0.970   0.334
#&gt; 3 snp3   -0.323      0.202    -1.60    0.113</code></pre>
</div>
<div id="the-full-minimal-workflow-for-a-robust-parallel-gwas" class="section level2">
<h2>The full, minimal workflow for a robust, parallel gwas</h2>
<pre class="r"><code>plan(multiprocess, workers = 4)

fit_model &lt;- function(snp_name, dat) {
      model_formula &lt;- glue(&quot;coffees ~ {snp_name}&quot;)
      fit &lt;- lm(model_formula, data = dat) %&gt;% 
                  broom::tidy() %&gt;% 
                  filter(term == snp_name)
      return(fit)
}

fit_model_safely &lt;- purrr::safely(fit_model)
gwas &lt;- future_map(snp_names, fit_model_safely, dat) %&gt;% 
                  map(&quot;result&quot;) %&gt;% 
                  bind_rows()

gwas[1:3, ]</code></pre>
<pre><code>#&gt; # A tibble: 3 x 5
#&gt;   term  estimate std.error statistic p.value
#&gt;   &lt;chr&gt;    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;
#&gt; 1 snp1    0.0266     0.212     0.126   0.900
#&gt; 2 snp2    0.201      0.207     0.970   0.334
#&gt; 3 snp3   -0.323      0.202    -1.60    0.113</code></pre>
</div>
<div id="general-thoughts-about-map" class="section level2">
<h2>General thoughts about map</h2>
<p><em>When to use map?</em></p>
<ul>
<li>Whenever more than two lines of code look similar, whenever a for loop needs two cups of coffee to be understood, map will be on your side</li>
</ul>
<p><em>Can every for-loop be replaced by a function and map?</em></p>
<ul>
<li>I think yes, but it becomes less practical when an iteration depends on the previous iteration, though I rarely encounter that problem</li>
</ul>
<p><em>What about the base R functions apply, sapply, lapply?</em></p>
<ul>
<li>lapply is very similar to map, though it lacks some very nice features which can be discovered over time. The other apply-functions can give surprising results, except for vapply, which is concise but slightly more complicated.</li>
</ul>
<p><em>What about map_df, map_lgl, map_dbl and all the other maps?</em></p>
<ul>
<li>All these functions differ in what their output is. However, the list resulting from simple map() can easily be transformed into any of these. After getting to grips with map, all the other maps fall into place.</li>
</ul>
<p><em>What if I have more than one vector or list as input?</em></p>
<ul>
<li>map2() takes two vectors as input and pmap() takes any number of vectors as input. I’m using pmap() to iterate over rows in a data.frame, but this is stuff for another blogpost I think.</li>
</ul>
</div>
<div id="where-to-go-from-here" class="section level2">
<h2>Where to go from here</h2>
<ul>
<li><p>Jenny Bryan’s <a href="https://jennybc.github.io/purrr-tutorial/index.html">purrr tutorials</a></p></li>
<li><p>Hadley Wickham’s <a href="https://www.youtube.com/watch?v=bzUmK0Y07ck&amp;t=2589s%5D">“The joy of functional programming”</a></p></li>
<li><p>R4DS chapter on <a href="https://r4ds.had.co.nz/iteration.html">iterations</a></p></li>
</ul>
</div>
</article>

        </main><footer id="footer">
    Copyright © 2021 Martin Stoffel
</footer>
</body>
</html>
